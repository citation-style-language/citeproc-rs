# `@citeproc-rs/wasm`

This is a front-end to 
[`citeproc-rs`](https://github.com/cormacrelf/citeproc-rs), a citation 
processor written in Rust and compiled to WebAssembly.

It contains builds appropriate for:

- Node.js
- Browsers, using a bundler like Webpack.js
- Browsers directly importing an ES Module from a webserver

## Installation / Release channels

There are two release channels:

**Stable** is each versioned release. (*At the time of writing, there are no 
versioned releases.*) Install with:

```sh
yarn add @citeproc-rs/wasm
```

**Canary** tracks the master branch [on 
GitHub](https://github.com/cormacrelf/citeproc-rs). Its version numbers follow 
the format `0.0.0-canary-GIT_COMMIT_SHA`, so version ranges in your 
`package.json` are not meaningful. But you can install the latest one with:

```sh
yarn add @citeproc-rs/wasm@canary
# alternatively, a specific commit
yarn add @citeproc-rs/wasm@0.0.0-canary-COMMIT_SHA
```

If you use NPM, replace `yarn add` with `npm install`.

### Including in your project

For Node.js, simply import the package as normal. Typescript definitions are 
provided, though parts of the API that cannot have auto-generated type 
definitions are alluded to in doc comments with an accompanying type you can 
import.

```
// Node.js
const { Driver } = require("@citeproc-rs/wasm");
```

#### Using Webpack

When loading on the web, for technical reasons and because the compiled 
WebAssembly is large, you must load the package asynchronously. Webpack comes 
with the ability to import packages asynchronously like so:

```javascript
// Webpack
import("@citeproc-rs/wasm")
    .then(go)
    .catch(console.error);

function go(wasm) {
    const { Driver } = wasm;
    // use Driver
}
```

When you do this, your code will trigger a download (and streaming parse) of 
the binary, and when that is complete, your `go` function will be called. The 
download can of course be cached if your web server is set up correctly, making 
the whole process very quick.

You can use the regular-import Driver as a TypeScript type anywhere, just don't 
use it to call `.new()`.

Note the caveats in around Microsoft Edge's TextEncoder/TextDecoder support in 
[the wasm-bindgen 
tutorial](https://rustwasm.github.io/docs/wasm-bindgen/examples/hello-world.html).

```typescript
import { Driver } from "@citeproc-rs/wasm";

function doSomethingWithDriver(driver: Driver) {
    // ...
}
```

#### Importing it in a script tag (`web` target)

To directly import it without a bundler in a (modern) web browser with ES 
modules support, the procedure is different. You must:

1. Make the `_web` subdirectory of the published NPM package available in a 
   content directory on your webserver, or use a CDN like [unpkg](unpkg.com).
2. Include a `<script type="module">` tag in your page's `<body>`, like so:

```html
<script type="module">
    import init, { Driver } from './path/to/_web/citeproc_rs_wasm.js';
    async function run() {
        await init();
        // use Driver
    }
    run()
</script>
```

#### Importing it in a script tag (`no-modules` target)

This replicates the [wasm-bindgen guide 
entry](https://rustwasm.github.io/docs/wasm-bindgen/examples/without-a-bundler.html?highlight=no-modules#using-the-older---target-no-modules), 
noting the caveats. You will, similarly to the `web` target, need to make the 
contents of the `_no_modules` subdirectory of the published NPM package 
available on a webserver or via a CDN.

```
<html>
  <head>
    <meta content="text/html;charset=utf-8" http-equiv="Content-Type"/>
  </head>
  <body>
    <!-- Include the JS generated by `wasm-pack build` -->
    <script src='path/to/@citeproc-rs/wasm/_no_modules/citeproc_rs_wasm.js'></script>

    <script>
      // Like with the `--target web` output the exports are immediately
      // available but they won't work until we initialize the module. Unlike
      // `--target web`, however, the globals are all stored on a
      // `wasm_bindgen` global. The global itself is the initialization
      // function and then the properties of the global are all the exported
      // functions.
      //
      // Note that the name `wasm_bindgen` will at some point be configurable with the
      // `--no-modules-global` CLI flag (https://github.com/rustwasm/wasm-pack/issues/729)
      const { Driver } = wasm_bindgen;

      async function run() {
        // Note the _bg.wasm ending
        await wasm_bindgen('path/to/@citeproc-rs/wasm/_no_modules/citeproc_rs_wasm_bg.wasm');

        // Use Driver
      }

      run();

    </script>
  </body>
</html>
```


## Usage


### Overview

The basic pattern of interactive use is:

1. Create a driver instance with your style
2. Edit the references or the citation clusters as you please
3. **Call `driver.batchedUpdates()`**
4. Apply the updates to your document (e.g. GUI)
5. Go to step 2 when a user makes a change

Step three is the important one. Each time you edit a cluster or a reference, 
it is common for only one or two visible modifications to result. Therefore, 
the driver only gives you those clusters or bibliography entries that have 
changed, or have been caused to change by an edit elsewhere. You can submit any 
number of edits between each call.

The API also allows for non-interactive use. See below.


### 1. Creating a driver instance

First, create a driver. Note that for now, you must also call `.free()` on the 
Driver when you are finished with it to deallocate its memory, but [there is a TC39 
proposal](https://rustwasm.github.io/docs/wasm-bindgen/reference/weak-references.html) 
in the implementation phase that will make this unnecessary.

A driver needs an XML style string, a fetcher (below), and an output format 
(one of `"html"`, `"rtf"` or `"plain"`).

```javascript
let driver = Driver.new(cslStyleTextAsXML, fetcher, "html");
// ... use the driver ...
driver.free()
```

The library parses and validates the CSL style input. Any validation errors are 
reported, with line/column positions, the text at that location, a descriptive 
and useful message (only in English at the moment) and sometimes even a hint 
for how to fix it. This is thrown as an error, which you can catch in a `try {} 
catch (e) {}` block.

#### Fetcher

There are hundreds of locales, and the locales you need change depending on the 
references that are active in your document, so the procedure for retrieving 
one is asynchronous to allow for fetching one over HTTP. There's not much more 
to it than this:

```javascript
class Fetcher {
    async fetchLocale(lang) {
        return fetch("https://some-cdn-with-locales.com/locales-${lang}.xml")
            .then(res => res.text());

        // or just
        // return "<locale> ... </locale>";
        // return LOCALES_PRELOADED[lang];

        // or if you don't support locales other than the bundled en-US!
        // return null;
    }
}

let fetcher = new Fetcher(); // Pass to Driver.new()
```

Unless you don't have `async` syntax, in which case, return a `Promise` 
directly, e.g. `return Promise.resolve("<locale> ... </locale>")`.

### 2. Edit the references or the citation clusters


#### References

You can insert a reference like so. This is a [CSL-JSON][schema] object.

[schema]: https://github.com/citation-style-language/schema

```javascript
driver.insertReference({ id: "citekey", type: "book", title: "Title" });
driver.insertReferences([ ... many references ... ]);
driver.resetReferences([ ... deletes any others ... ]);
driver.removeReference("citekey");
```

When you do insert a reference, it may have locale information in it. This 
should be done after updating the references, so any new locales can be 
fetched.

```javascript
// May call your Fetcher instance.
await driver.fetchAll();
```

#### Citation Clusters and their Cites

A document consists of a series of clusters, each with a series of cites. Each 
cluster has an `id`, which is any integer except zero.

```javascript
// initClusters is like booting up an existing document and getting up to speed
driver.initClusters([
    { id: 1, cites: [ {id: "citekey"} ] },
    { id: 2, cites: [ {id: "citekey", locator: "56", label: "page" } ] },
]);
// Update or insert any one of them like so
driver.insertCluster({ id: 1, cites: [ { id: "updated_citekey" } ] });
driver.insertCluster({ id: 3, cites: [ { id: "new_cluster_here" } ] });
```

These clusters do not contain position information, so reordering is a separate 
procedure. **Without calling setClusterOrder, the driver considers the document 
to be empty.**

So, `setClusterOrder` expresses the ordering of the clusters within the 
document. Each one in the document should appear in this list. You can skip 
note numbers, which means there were non-citing footnotes in between. Omitting 
`note` means it's an in-text reference. Note numbers must be monotonic, but you 
can have more than one cluster in the same footnote.

```javascript
driver.setClusterOrder([ { id: 1, note: 1 }, { id: 2, note: 4 } ]);
```

You will notice that if an interactive user cuts and pastes a paragraph 
containing citation clusters, the whole reordering operation can be expressed 
in two calls, one after the cut (with some clusters omitted) and one after the 
paste (with those same clusters placed somewhere else). No calls to 
`insertCluster` need be made.

#### Uncited items

Sometimes a user wishes to include references in the bibliography even though 
they are not mentioned in a citation anywhere in the document.

```javascript
driver.includeUncited("None"); // Default
driver.includeUncited("All");
driver.includeUncited({ Specific: ["citekeyA", "citekeyB"] });
```

### 3. Call `driver.batchedUpdates()` and apply the diff

This gets you a diff to apply to your document UI. It includes both clusters 
that have changed, and bibliography entries that have changed.

```javascript
import { UpdateSummary } from "@citeproc-rs/wasm"; // typescript users, annotate with this

let diff = driver.batchedUpdates();

// apply to the UI
diff.clusters.forEach(changedCluster => {
    let [id, html] = changedCluster;
    myDocument.updateCluster(id, html);
});

// Null? No change to the bibliography.
if (diff.bibliography != null) {
    let bib = diff.bibliography;
    // entryIds is the full list of entries in the bibliography.
    // If a citekey isn't in there, it should be removed.
    myDocument.removeAbsentEntryIds(bib.entryIds);
    // Then, apply the entries that have actually changed
    for (let key of Object.keys(bib.updatedEntries)) {
        let rendered = bib.updatedEntries[key];
        myDocument.updateBibEntry(key, rendered);
    }
}
```

Note, for some intuition, if you call `batchedUpdates()` again immediately, the 
diff will be empty.

### Bibliographies

There are two functions for producing a bibliography.

```javascript
// returns BibliographyMeta
let meta = driver.bibliographyMeta();

// This is an array of BibEntry
let bibliography = driver.makeBibliography();
for (let entry of bibliography) {
}
```

### Preview citation clusters

Sometimes, a user wants to see how a cluster will look while they are editing 
it, before confirming the change.

```javascript
let cites = [ { id: "citekey", locator: "45" }, { ... } ];
let positions = [ ... before, { id: 0, note: 34 }, ... after ];
let preview = driver.previewCitationCluster(cites, positions, "html");
```

The positions array is exactly like a call to `setClusterOrder`, except exactly 
one of the positions has an id of 0. This could either:

- Replace an existing cluster's position, and preview a cluster replacement; or
- Represent the position a cluster is hypothetically inserted.

If you passed only one position, it would be like previewing an operation like 
"delete the entire document and replace it with this one cluster". **That would 
mean you would never see "ibid" in a preview.** So for maximum utility, 
assemble the positions array as you would a call to `setClusterOrder` with 
exactly the operation you're previewing applied.



### Non-Interactive use, or re-hydrating a previously created document

If you are working non-interactively, or re-hydrating a previously created 
document for interactive use, you may want to do one pass over all the clusters 
in the document, so that each cluster and bibliography entry reflects the 
correct value.

```javascript
// Get the clusters from your document (example)
let allNotes = myDocument.footnotes.map(fn => {
    return { cluster: getCluster(fn), number: fn.number }
});

// Re-hydrate the entire document
driver.resetReferences(allReferences);
driver.initClusters(allNotes.map(fn => fn.cluster));
driver.setClusterOrder(allNotes.map(fn => { id: fn.cluster.id, note: fn.number }));

// Render every cluster and bibliography item.
// It then drains the update queue, leaving the diff empty for the next edit.
// see the FullRender typescript type
let render = driver.fullRender();

// Write out the rendered clusters into the doc
for (let fn of allNotes) {
    fn.renderedHtml = render.allClusters[fn.cluster.id];
}

// Write out the bibliography entries as well
let allBibKeys = render.bib_entries.map(entry => entry.id);
for (let bibEntry of render.bibEntries) {
    myDocument.bibliographyMap[entry.id] = entry.value;
}

// Update the UI
updateUserInterface(allNotes, myDocument, whatever);
```


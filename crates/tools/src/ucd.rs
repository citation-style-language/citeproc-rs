use anyhow::Error;
use std::collections::BTreeMap;
use std::collections::BTreeSet;
use std::env;
use std::fs::File;
use std::io::prelude::*;
use std::io::BufReader;
use std::path::Path;
use std::process::{Command, Stdio};
use std::str::FromStr;
use ucd_parse::{Codepoint, UnicodeData};

use super::workspace_root;

fn parse_ucd_file(file: impl AsRef<Path>) -> Result<Vec<UnicodeData>> {
    let file = BufReader::new(File::open(file)?);
    let mut vec = Vec::new();
    for line in file.lines() {
        vec.push(UnicodeData::from_str(&line?)?);
    }
    Ok(vec)
}

// ucd-generate is not available as a library

// (doesn't work for non-completely-scalar decompositions, but exits without printing anything so
// we're OK I think)
fn codepoints_to_string(cps: &[Codepoint]) -> String {
    let mut string = String::with_capacity(cps.len());
    for cp in cps {
        if let Some(scalar) = cp.scalar() {
            if scalar == '\x00' {
                break;
            }
            string.push(scalar);
        } else {
            println!("Not a scalar {:?}", cp);
        }
    }
    string
}

// https://github.com/BurntSushi/ucd-generate/blob/master/src/writer.rs
struct Writer<W: Write> {
    wtr: W,
    scalar: bool,
}

type Result<T> = std::result::Result<T, Error>;

impl<W: Write> Writer<W> {
    fn rust_codepoint(&self, cp: u32) -> Option<String> {
        if self.scalar {
            std::char::from_u32(cp).map(|c| format!("{:?}", c))
        } else {
            Some(format!("{}", cp))
        }
    }

    fn header(&mut self) -> Result<()> {
        write!(
            self.wtr,
            r##"//
// DO NOT EDIT THIS FILE
// It was generated automatically via `cargo tools build-ucd`

#![allow(dead_code)]
#![allow(clippy::all)]

"##
        )?;
        Ok(())
    }

    fn lookup(&mut self, name: &str, lookup: &BTreeMap<Codepoint, String>) -> Result<()> {
        let ty = if self.scalar { "char" } else { "u32" };
        write!(
            self.wtr,
            r#"
/// Takes a unicode codepoint for a super- or subscript character, and returns 
/// a &str of its decomposition. (&str not char, because ^TM for example is two chars.)
pub fn {name}(cp: {ty}) -> &'static str {{
    match cp as {ty} {{
"#,
            name = name,
            ty = ty
        )?;
        for (cp, string) in lookup.iter() {
            if let Some(c) = cp
                .scalar()
                .and_then(|x| if self.scalar { Some(x) } else { None })
            {
                write!(self.wtr, "        {:?} => {:?},\n", c, string)?;
            } else {
                write!(self.wtr, "        {} => {:?},\n", cp.value(), string)?;
            }
        }
        write!(
            self.wtr,
            r#"        _ => panic!("unknown codepoint in {name} lookup function")"#,
            name = name
        )?;
        write!(
            self.wtr,
            r#"
    }}
}}
"#
        )?;
        Ok(())
    }

    fn ranges(&mut self, name: &str, codepoints: &BTreeSet<u32>) -> Result<()> {
        let ranges = util::to_ranges(codepoints.iter().cloned());
        Ok(self.ranges_slice(&name, &ranges)?)
    }

    fn ranges_slice(&mut self, name: &str, table: &[(u32, u32)]) -> Result<()> {
        let ty = if self.scalar { "char" } else { "u32" };
        writeln!(
            self.wtr,
            "pub const {}: &'static [({}, {})] = &[",
            name, ty, ty
        )?;
        for &(start, end) in table {
            let range = (self.rust_codepoint(start), self.rust_codepoint(end));
            if let (Some(start), Some(end)) = range {
                write!(self.wtr, "({}, {}), ", start, end)?;
            }
        }
        writeln!(self.wtr, "];")?;
        Ok(())
    }
}

mod util {
    /// Convert an iterator of codepoints into a vec of sorted ranges.
    pub fn to_ranges<I: IntoIterator<Item = u32>>(it: I) -> Vec<(u32, u32)> {
        let mut codepoints: Vec<u32> = it.into_iter().collect();
        codepoints.sort();
        codepoints.dedup();
        let mut ranges = vec![];
        for cp in codepoints {
            range_add(&mut ranges, cp);
        }
        ranges
    }
    pub fn range_add(ranges: &mut Vec<(u32, u32)>, codepoint: u32) {
        if let Some(&mut (_, ref mut end)) = ranges.last_mut() {
            assert!(*end < codepoint);
            if codepoint == *end + 1 {
                *end = codepoint;
                return;
            }
        }
        ranges.push((codepoint, codepoint));
    }
}

pub fn build_superscript_trie() -> Result<()> {
    let mut path = workspace_root();
    path.push("crates");
    path.push("io");
    path.push("src");
    path.push("unicode");
    env::set_var("UCD_RUST_OUT_DIR", &path);
    path.pop();
    path.pop();
    env::set_current_dir(&path)?;
    let status = Command::new("sh")
        .arg("ucd.sh")
        .stdout(Stdio::inherit())
        .stderr(Stdio::inherit())
        .spawn()?
        .wait()?;
    if !status.success() {
        return Err(anyhow::anyhow!("failed to execute ucd.sh"))
    }
    let ucd = parse_ucd_file("/tmp/ucd/Superscript.txt")?;
    let mut membership = BTreeSet::new();
    let mut lookup = BTreeMap::new();
    for line in ucd {
        membership.insert(line.codepoint.value());
        let s = codepoints_to_string(&line.decomposition.mapping);
        lookup.insert(line.codepoint, s);
    }
    let ucd = parse_ucd_file("/tmp/ucd/Subscript.txt")?;
    let mut sub_membership = BTreeSet::new();
    for line in ucd {
        sub_membership.insert(line.codepoint.value());
        let s = codepoints_to_string(&line.decomposition.mapping);
        lookup.insert(line.codepoint, s);
    }
    path.push("src");
    path.push("unicode");
    std::fs::create_dir_all(&path)?;
    path.push("sup_sub.rs");

    let mut writer = Writer {
        wtr: File::create(&path)?,
        scalar: true,
    };
    writer.header()?;
    writer.ranges("SUPERSCRIPT_MEMBERSHIP", &membership)?;
    writer.ranges("SUBSCRIPT_MEMBERSHIP", &sub_membership)?;
    writer.lookup("lookup_decomposition", &lookup)?;

    Ok(())
}
